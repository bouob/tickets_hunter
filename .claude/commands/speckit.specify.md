---
description: "根據自然語言的功能描述，建立或更新功能規格說明。"
model: opus
handoffs:
  - label: Build Technical Plan
    agent: speckit.plan
    prompt: Create a plan for the spec. I am building with...
  - label: Clarify Spec Requirements
    agent: speckit.clarify
    prompt: Clarify specification requirements
    send: true
---

## 使用者輸入

```text
$ARGUMENTS
```

您 **必須** 在繼續之前考量使用者輸入（如非空白）。

## 大綱

使用者在觸發訊息中 `/speckit.specify` 後輸入的文字 **就是** 功能描述。假設您在此對話中始終可以存取它，即使 `$ARGUMENTS` 在下方以字面形式出現。除非使用者提供了空指令，否則不要要求使用者重複。

根據該功能描述，執行以下操作：

1. **產生簡潔的短名稱**（2-4 個字）用於分支：
   - 分析功能描述並擷取最有意義的關鍵字
   - 建立一個 2-4 個字的短名稱，擷取功能的本質
   - 盡可能使用動作-名詞格式（例如，"add-user-auth"、"fix-payment-bug"）
   - 保留技術術語和縮寫（OAuth2、API、JWT 等）
   - 保持簡潔但足夠描述性，以便一眼理解功能
   - 範例：
     - "I want to add user authentication" → "user-auth"
     - "Implement OAuth2 integration for the API" → "oauth2-api-integration"
     - "Create a dashboard for analytics" → "analytics-dashboard"
     - "Fix payment processing timeout bug" → "fix-payment-timeout"

2. **在建立新分支前檢查現有分支**：

   a. 首先，擷取所有遠端分支以確保我們有最新資訊：
      ```bash
      git fetch --all --prune
      ```

   b. 在所有來源中找到該短名稱的最高功能編號：
      - 遠端分支：`git ls-remote --heads origin | grep -E 'refs/heads/[0-9]+-<short-name>$'`
      - 本地分支：`git branch | grep -E '^[* ]*[0-9]+-<short-name>$'`
      - Specs 目錄：檢查符合 `specs/[0-9]+-<short-name>` 的目錄

   c. 決定下一個可用編號：
      - 從所有三個來源擷取所有編號
      - 找到最高編號 N
      - 使用 N+1 作為新分支編號

   d. 使用計算的編號和短名稱執行腳本 `.specify/scripts/powershell/create-new-feature.ps1 -Json "$ARGUMENTS"`：
      - 連同功能描述一起傳遞 `--number N+1` 和 `--short-name "your-short-name"`
      - Bash 範例：`.specify/scripts/powershell/create-new-feature.ps1 -Json "$ARGUMENTS" --json --number 5 --short-name "user-auth" "Add user authentication"`
      - PowerShell 範例：`.specify/scripts/powershell/create-new-feature.ps1 -Json "$ARGUMENTS" -Json -Number 5 -ShortName "user-auth" "Add user authentication"`

   **重要**：
   - 檢查所有三個來源（遠端分支、本地分支、specs 目錄）以找到最高編號
   - 僅匹配具有確切短名稱模式的分支/目錄
   - 如果未找到具有此短名稱的現有分支/目錄，從編號 1 開始
   - 每個功能只能執行此腳本一次
   - JSON 在終端機中作為輸出提供——始終參考它以取得您尋找的實際內容
   - JSON 輸出將包含 BRANCH_NAME 和 SPEC_FILE 路徑
   - 對於參數中的單引號（如 "I'm Groot"），使用跳脫語法：例如 'I'\''m Groot'（或盡可能使用雙引號："I'm Groot"）

3. 載入 `.specify/templates/spec-template.md` 以理解必要區塊。

4. 依循此執行流程：

    1. 從輸入解析使用者描述
       如果為空：報錯「未提供功能描述」
    2. 從描述擷取關鍵概念
       識別：角色、動作、資料、限制
    3. 對於不清楚的面向：
       - 根據環境和業界標準做出有根據的猜測
       - 僅在以下情況標記 [需要釐清: 具體問題]：
         - 選擇顯著影響功能範圍或使用者體驗
         - 存在多個具有不同含義的合理詮釋
         - 不存在合理的預設值
       - **限制：最多 3 個 [需要釐清] 標記**
       - 按影響排定釐清優先順序：範圍 > 安全性/隱私 > 使用者體驗 > 技術細節
    4. 填寫使用者情境與測試區塊
       如果沒有清楚的使用者流程：報錯「無法判斷使用者情境」
    5. 產生功能需求
       每個需求必須可測試
       對於未指定的細節使用合理預設（在假設區塊記錄假設）
    6. 定義成功標準
       建立可衡量的、與技術無關的結果
       包含定量指標（時間、效能、數量）和定性衡量（使用者滿意度、任務完成率）
       每個標準必須在不知道實作細節的情況下可驗證
    7. 識別關鍵實體（如涉及資料）
    8. 回傳：成功（規格已準備好進行規劃）

5. 使用模板結構將規格寫入 SPEC_FILE，將佔位符替換為從功能描述（參數）導出的具體細節，同時保留區塊順序和標題。

6. **規格品質驗證**：撰寫初始規格後，依據品質標準驗證：

   a. **建立規格品質檢查清單**：在 `FEATURE_DIR/checklists/requirements.md` 建立檢查清單檔案，使用檢查清單模板結構和這些驗證項目：

      ```markdown
      # 規格品質檢查清單：[功能名稱]

      **目的**：在進行規劃前驗證規格完整性和品質
      **建立日期**：[日期]
      **功能**：[連結到 spec.md]

      ## 內容品質

      - [ ] 無實作細節（語言、框架、API）
      - [ ] 專注於使用者價值和業務需求
      - [ ] 為非技術利害關係人撰寫
      - [ ] 所有強制區塊已完成

      ## 需求完整性

      - [ ] 沒有剩餘的 [需要釐清] 標記
      - [ ] 需求可測試且明確無歧義
      - [ ] 成功標準可衡量
      - [ ] 成功標準與技術無關（無實作細節）
      - [ ] 所有驗收情境已定義
      - [ ] 已識別邊界案例
      - [ ] 範圍有清楚的邊界
      - [ ] 已識別相依性和假設

      ## 功能準備度

      - [ ] 所有功能需求有清楚的驗收標準
      - [ ] 使用者情境涵蓋主要流程
      - [ ] 功能符合成功標準中定義的可衡量結果
      - [ ] 沒有實作細節洩漏到規格中

      ## 註記

      - 標記為未完成的項目需要在 `/speckit.clarify` 或 `/speckit.plan` 之前更新規格
      ```

   b. **執行驗證檢查**：依據每個檢查清單項目審查規格：
      - 對於每個項目，判斷是否通過或失敗
      - 記錄發現的具體問題（引用相關規格區塊）

   c. **處理驗證結果**：

      - **如果所有項目通過**：標記檢查清單完成並繼續到步驟 6

      - **如果項目失敗（排除 [需要釐清]）**：
        1. 列出失敗的項目和具體問題
        2. 更新規格以解決每個問題
        3. 重新執行驗證直到所有項目通過（最多 3 次迭代）
        4. 如果 3 次迭代後仍然失敗，在檢查清單註記中記錄剩餘問題並警告使用者

      - **如果 [需要釐清] 標記剩餘**：
        1. 從規格擷取所有 [需要釐清: ...] 標記
        2. **限制檢查**：如果存在超過 3 個標記，僅保留最關鍵的 3 個（按範圍/安全性/UX 影響），其餘做出有根據的猜測
        3. 對於每個需要釐清的項目（最多 3 個），以此格式向使用者呈現選項：

           ```markdown
           ## 問題 [N]：[主題]

           **環境**：[引用相關規格區塊]

           **我們需要知道什麼**：[來自需要釐清標記的具體問題]

           **建議答案**：

           | 選項 | 答案 | 含義 |
           |------|------|------|
           | A    | [第一個建議答案] | [這對功能意味著什麼] |
           | B    | [第二個建議答案] | [這對功能意味著什麼] |
           | C    | [第三個建議答案] | [這對功能意味著什麼] |
           | 自訂 | 提供您自己的答案 | [解釋如何提供自訂輸入] |

           **您的選擇**：_[等待使用者回應]_
           ```

        4. **關鍵 - 表格格式**：確保 Markdown 表格格式正確：
           - 使用一致的間距，對齊管線符號
           - 每個儲存格內容周圍應有空格：`| Content |` 而非 `|Content|`
           - 標題分隔符至少要有 3 個破折號：`|--------|`
           - 測試表格在 Markdown 預覽中是否正確渲染
        5. 依序編號問題（Q1、Q2、Q3 - 最多 3 個）
        6. 在等待回應前一起呈現所有問題
        7. 等待使用者回應他們對所有問題的選擇（例如，"Q1: A, Q2: 自訂 - [細節], Q3: B"）
        8. 用使用者選擇或提供的答案取代每個 [需要釐清] 標記來更新規格
        9. 所有釐清解決後重新執行驗證

   d. **更新檢查清單**：每次驗證迭代後，更新檢查清單檔案的當前通過/失敗狀態

7. 報告完成，包含分支名稱、規格檔案路徑、檢查清單結果，以及下一階段的準備度（`/speckit.clarify` 或 `/speckit.plan`）。

**注意：** 腳本在寫入前會建立並切換到新分支，並初始化規格檔案。

## 一般指南

## 快速指南

- 專注於使用者需要 **什麼** 和 **為什麼**。
- 避免如何實作（無技術堆疊、API、程式碼結構）。
- 為業務利害關係人撰寫，而非開發人員。
- **不要** 建立任何嵌入規格中的檢查清單。那將是單獨的指令。

### 區塊需求

- **強制區塊**：每個功能必須完成
- **可選區塊**：僅在與功能相關時包含
- 當區塊不適用時，完全移除它（不要留下「N/A」）

### AI 產生用

從使用者提示建立此規格時：

1. **做出有根據的猜測**：使用環境、業界標準和常見模式來填補缺口
2. **記錄假設**：在假設區塊記錄合理的預設值
3. **限制釐清**：最多 3 個 [需要釐清] 標記——僅用於以下關鍵決策：
   - 顯著影響功能範圍或使用者體驗
   - 有多個具有不同含義的合理詮釋
   - 缺乏任何合理的預設值
4. **排定釐清優先順序**：範圍 > 安全性/隱私 > 使用者體驗 > 技術細節
5. **像測試人員一樣思考**：每個模糊的需求都應該在「可測試且明確無歧義」檢查清單項目上失敗
6. **常見需要釐清的領域**（僅在沒有合理預設值時）：
   - 功能範圍和邊界（包含/排除特定用例）
   - 使用者類型和權限（如有多個衝突的詮釋可能）
   - 安全性/合規需求（當在法律/財務上有重大影響時）

**合理預設值的範例**（不要詢問這些）：

- 資料保留：該領域的業界標準做法
- 效能目標：標準網頁/行動應用程式預期，除非另有指定
- 錯誤處理：友善的使用者訊息和適當的後備方案
- 驗證方法：網頁應用程式的標準 session-based 或 OAuth2
- 整合模式：除非另有指定，否則為 RESTful API

### 成功標準指南

成功標準必須是：

1. **可衡量的**：包含具體指標（時間、百分比、數量、比率）
2. **與技術無關的**：不提及框架、語言、資料庫或工具
3. **以使用者為中心的**：從使用者/業務角度描述結果，而非系統內部
4. **可驗證的**：可在不知道實作細節的情況下測試/驗證

**好的範例**：

- 「使用者可在 3 分鐘內完成結帳」
- 「系統支援 10,000 個並發使用者」
- 「95% 的搜尋在 1 秒內回傳結果」
- 「任務完成率提高 40%」

**不好的範例**（以實作為中心）：

- 「API 回應時間低於 200ms」（太技術性，使用「使用者即時看到結果」）
- 「資料庫可處理 1000 TPS」（實作細節，使用面向使用者的指標）
- 「React 元件高效渲染」（框架特定）
- 「Redis 快取命中率高於 80%」（技術特定）
